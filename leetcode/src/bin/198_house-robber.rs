/*
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
*/

struct Solution;
impl Solution {
    /*
     * 只存在2种状态，偷或者不偷，因为都是非负的数，全部都偷是金额最大的，所以应该是尽可能的偷；
     * 这种情况下，不偷 只能是因为限制条件的因素导致，所以第k项不偷的话，就说明前面 k-1
     * 肯定是偷的；因为如果k-1不偷，那么最后的金额肯定不会是最大的。
     * 所以第k项偷或者不偷，就有状态转移矩阵： dp[k] = max(dp[k-1], dp[k-2]+nums[k])
     */
    pub fn rob(nums: Vec<i32>) -> i32 {
        let len = nums.len();
        let mut dp = vec![0;len];
        dp[0] = nums[0];
        if len == 1 {
            return dp[0];
        }
        dp[1] = std::cmp::max(nums[0], nums[1]);
        if len == 2 {
            return dp[1];
        }
        for i in 2..nums.len() {
            dp[i] = std::cmp::max(dp[i-1], dp[i-2] + nums[i]);
        } 

        dp[len-1]
    }
    //从后向前推的版本
    pub fn rob2(nums: Vec<i32>) -> i32 {

        0
    }
}

pub fn main() {
    let nums = vec![1,2,3,1];
    //let nums = vec![2,7,9,3,1];
    println!("{:?}", nums);
    let ans = Solution::rob(nums);
    println!("ans: {:?}", ans);
}

